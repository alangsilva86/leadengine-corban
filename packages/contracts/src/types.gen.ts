/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/tickets/{ticketId}/messages": {
    /**
     * Enfileira uma nova mensagem para um ticket existente
     * @description Recebe os dados de uma nova mensagem outbound associada a um ticket existente e retorna o status do enfileiramento.
     */
    post: operations["createTicketMessage"];
  };
  "/api/v1/agreements": {
    /**
     * Lista acordos comerciais
     * @description Retorna uma coleção paginada de acordos aplicando filtros de status, provedor e período de vigência.
     */
    get: operations["listAgreements"];
    /**
     * Cria um novo acordo comercial
     * @description Registra um novo acordo com suas tabelas, janelas e taxas vigentes.
     */
    post: operations["createAgreement"];
  };
  "/api/v1/agreements/{agreementId}": {
    /**
     * Recupera detalhes de um acordo comercial
     * @description Retorna o acordo completo com tabelas, janelas, taxas e metadados vigentes.
     */
    get: operations["getAgreement"];
    /**
     * Atualiza parcialmente um acordo comercial
     * @description Permite ajustes pontuais no acordo, como mudança de status, vigência ou definição de novas taxas.
     */
    patch: operations["updateAgreement"];
    parameters: {
      path: {
        /** @description Identificador único do acordo. */
        agreementId: string;
      };
    };
  };
  "/api/v1/agreements/import": {
    /**
     * Importa acordos comerciais em lote
     * @description Permite subir novos acordos em massa via upload de planilha ou JSON estruturado. A importação é assíncrona e retorna o identificador do job.
     */
    post: operations["importAgreements"];
  };
  "/api/v1/agreements/providers/{providerId}/sync": {
    /**
     * Dispara sincronização de acordos para um provedor
     * @description Agenda uma sincronização assíncrona dos acordos ativos com o provedor remoto.
     */
    post: operations["triggerProviderAgreementSync"];
  };
  "/api/contacts/{contactId}/messages": {
    /**
     * Enfileira uma nova mensagem para um contato específico
     * @description Cria uma nova mensagem outbound vinculada a um contato e opcionalmente a uma instância específica de WhatsApp.
     */
    post: operations["createContactMessage"];
  };
  "/api/integrations/whatsapp/instances/{instanceId}/messages": {
    /**
     * Enfileira uma nova mensagem para envio ad-hoc via instância WhatsApp
     * @description Permite enviar mensagens outbound ad-hoc usando apenas a instância do WhatsApp e o telefone de destino.
     */
    post: operations["createInstanceMessage"];
  };
  "/api/users": {
    /**
     * Lista usuários do tenant autenticado
     * @description Retorna os usuários cadastrados no tenant filtrando por status ativo ou inativo.
     */
    get: operations["listUsers"];
    /** Cria um novo usuário para o tenant */
    post: operations["createUser"];
  };
  "/api/users/invites": {
    /** Gera um convite para um novo usuário do tenant */
    post: operations["createUserInvite"];
  };
  "/api/users/{userId}": {
    /** Desativa um usuário do tenant */
    delete: operations["deactivateUser"];
    /** Atualiza role ou status de um usuário existente */
    patch: operations["updateUser"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** @description Metadados opcionais enviados pelo consumidor para rastreabilidade. */
    RequestMeta: {
      /** @description Identificador fornecido pelo cliente para correlacionar requisições. */
      correlationId?: string;
      /** @description Nome do sistema cliente que originou a requisição. */
      source?: string;
    };
    /** @description Metainformações retornadas pelo serviço em todas as respostas de sucesso. */
    ResponseMeta: {
      /** @description Identificador único da requisição gerado pelo serviço. */
      requestId?: string;
      /**
       * Format: date-time
       * @description Timestamp em que a resposta foi gerada (ISO 8601, UTC).
       */
      generatedAt?: string;
      /** @description Versão da API que produziu a resposta. */
      version?: string;
    };
    PaginationMeta: {
      page: number;
      pageSize: number;
      totalItems: number;
      totalPages: number;
      hasNext?: boolean;
      hasPrevious?: boolean;
    };
    /**
     * @description Situação operacional do acordo.
     * @enum {string}
     */
    AgreementStatus: "draft" | "active" | "published" | "suspended" | "terminated" | "archived";
    /**
     * @description Identifica a forma de cálculo aplicada pela taxa.
     * @enum {string}
     */
    AgreementRateType: "flat" | "percentage" | "tiered";
    AgreementRateTier: {
      id?: string;
      fromVolume: number;
      /** @description Volume máximo (inclusive) suportado pela faixa. Null indica ausência de limite superior. */
      toVolume: number | null;
      /** @description Valor aplicado para a faixa informada. */
      value: number;
      /** @description Código da moeda ISO-4217 aplicável quando a faixa utiliza valor fixo. */
      currency?: string;
    };
    LegacyAgreementRateBase: {
      type: components["schemas"]["AgreementRateType"];
      description?: string;
      /** @description Valor absoluto aplicado para taxas do tipo flat ou percentual (0-100). */
      value?: number;
      /** @description Código da moeda ISO-4217 quando aplicável. */
      currency?: string;
      /** @description Precisão decimal para taxas percentuais. */
      percentageDecimals?: number;
      minimumValue?: number;
      maximumValue?: number;
      /** @description Coleção de faixas aplicável quando type=tiered. */
      tiers?: components["schemas"]["AgreementRateTier"][];
      /** @description Identificadores das janelas às quais a taxa se aplica. */
      windowIds?: string[];
    };
    LegacyAgreementRate: components["schemas"]["LegacyAgreementRateBase"] & {
      id: string;
    };
    LegacyAgreementRateInput: components["schemas"]["LegacyAgreementRateBase"] & {
      id?: string;
    };
    LegacyAgreementWindowBase: {
      /** @description Nome exibido da janela. */
      label: string;
      /** @description Timezone IANA aplicado às janelas. */
      timezone: string;
      daysOfWeek: ("monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday")[];
      /** @description Horário de início no formato HH:mm. */
      startTime: string;
      /** @description Horário de término no formato HH:mm. */
      endTime: string;
      /** Format: date */
      startDate?: string;
      /** Format: date */
      endDate?: string | null;
      /** @description Metadados adicionais específicos da janela. */
      attributes?: {
        [key: string]: unknown;
      };
    };
    LegacyAgreementWindow: components["schemas"]["LegacyAgreementWindowBase"] & {
      id: string;
    };
    LegacyAgreementWindowInput: components["schemas"]["LegacyAgreementWindowBase"] & {
      id?: string;
    };
    AgreementTableBase: {
      name: string;
      description?: string;
      externalCode?: string;
      /** @description Código da moeda ISO-4217 utilizada como base para os valores. */
      currency: string;
      /** @description Ordem de aplicação da tabela. */
      priority?: number;
      windows?: components["schemas"]["LegacyAgreementWindowInput"][];
      rates: components["schemas"]["LegacyAgreementRateInput"][];
      metadata?: {
        [key: string]: unknown;
      };
    };
    AgreementTable: components["schemas"]["AgreementTableBase"] & {
      id: string;
      windows?: components["schemas"]["LegacyAgreementWindow"][];
      rates?: components["schemas"]["LegacyAgreementRate"][];
    };
    AgreementTableInput: components["schemas"]["AgreementTableBase"] & {
      id?: string;
    };
    AgreementDetail: {
      id: string;
      providerId: string;
      externalCode?: string | null;
      name: string;
      description?: string | null;
      status: components["schemas"]["AgreementStatus"];
      version: number;
      /** Format: date-time */
      validFrom: string;
      /** Format: date-time */
      validUntil?: string | null;
      tags?: string[];
      tables: components["schemas"]["AgreementTable"][];
      metadata?: {
        [key: string]: unknown;
      };
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    AgreementSummary: {
      id: string;
      providerId: string;
      externalCode?: string | null;
      name: string;
      status: components["schemas"]["AgreementStatus"];
      version: number;
      /** Format: date-time */
      validFrom: string;
      /** Format: date-time */
      validUntil?: string | null;
      tableCount: number;
      primaryCurrency?: string;
      /** Format: date-time */
      lastSyncedAt?: string | null;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    AgreementListFilters: {
      statuses?: components["schemas"]["AgreementStatus"][];
      providerIds?: string[];
      /** Format: date-time */
      validOn?: string;
      search?: string;
    };
    AgreementListMeta: components["schemas"]["ResponseMeta"] & {
      pagination: components["schemas"]["PaginationMeta"];
      filters?: components["schemas"]["AgreementListFilters"];
    };
    AgreementListResponse: {
      data: components["schemas"]["AgreementSummary"][];
      meta: components["schemas"]["AgreementListMeta"];
    };
    AgreementResponse: {
      data: components["schemas"]["AgreementDetail"];
      meta: components["schemas"]["ResponseMeta"];
    };
    AgreementWritePayload: {
      providerId: string;
      externalCode?: string;
      name: string;
      description?: string;
      status: components["schemas"]["AgreementStatus"];
      /** Format: date-time */
      validFrom: string;
      /** Format: date-time */
      validUntil?: string | null;
      tags?: string[];
      tables: components["schemas"]["AgreementTableInput"][];
      metadata?: {
        [key: string]: unknown;
      };
    };
    AgreementCreateRequest: {
      data: components["schemas"]["AgreementWritePayload"];
      meta?: components["schemas"]["RequestMeta"];
    };
    LegacyAgreementUpdatePayload: {
      name?: string;
      description?: string;
      status?: components["schemas"]["AgreementStatus"];
      /** Format: date-time */
      validFrom?: string;
      /** Format: date-time */
      validUntil?: string | null;
      tags?: string[];
      tables?: components["schemas"]["AgreementTableInput"][];
      metadata?: {
        [key: string]: unknown;
      };
    };
    LegacyAgreementUpdateRequest: {
      data: components["schemas"]["LegacyAgreementUpdatePayload"];
      meta?: components["schemas"]["RequestMeta"];
    };
    AgreementImportInput: {
      providerId: string;
      /** @default false */
      dryRun?: boolean;
      notifyEmails?: string[];
      agreements?: components["schemas"]["AgreementWritePayload"][];
    };
    AgreementImportRequest: {
      data: components["schemas"]["AgreementImportInput"];
      meta?: components["schemas"]["RequestMeta"];
    };
    AgreementImportMultipartRequest: {
      providerId: string;
      /** @default false */
      dryRun?: boolean;
      notifyEmails?: string[];
      /** Format: binary */
      file: string;
    };
    AgreementImportJob: {
      /** @description Identificador da importação. */
      id: string;
      /** @enum {string} */
      status: "queued" | "processing" | "completed" | "failed";
      dryRun: boolean;
      receivedAgreements: number;
      importedAgreements?: number;
      skippedAgreements?: number;
      errors?: string[];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      completedAt?: string | null;
      /** Format: date-time */
      expiresAt?: string | null;
    };
    LegacyAgreementImportResponse: {
      data: components["schemas"]["AgreementImportJob"];
      meta: components["schemas"]["ResponseMeta"];
    };
    ProviderSyncRequest: {
      /** @description Força uma sincronização completa, ignorando caches. */
      forceFullRefresh?: boolean;
      correlationId?: string;
      /** @description Identificador do operador que iniciou a sincronização. */
      requestedBy?: string;
    };
    ProviderSyncStatus: {
      providerId: string;
      jobId: string;
      /** @enum {string} */
      status: "queued" | "syncing" | "completed" | "failed";
      /** Format: date-time */
      triggeredAt: string;
      /** Format: date-time */
      lastSuccessfulSyncAt?: string | null;
      /** Format: date-time */
      estimatedCompletionAt?: string | null;
      warnings?: string[];
      message?: string;
    };
    ProviderSyncResponse: {
      data: components["schemas"]["ProviderSyncStatus"];
      meta: components["schemas"]["ResponseMeta"];
    };
    MessagePayload: components["schemas"]["TextMessagePayload"] | components["schemas"]["ImageMessagePayload"] | components["schemas"]["DocumentMessagePayload"] | components["schemas"]["AudioMessagePayload"] | components["schemas"]["VideoMessagePayload"] | components["schemas"]["LocationMessagePayload"] | components["schemas"]["ContactMessagePayload"] | components["schemas"]["TemplateMessagePayload"] | components["schemas"]["PollMessagePayload"];
    MessagePreviewSupport: {
      previewUrl?: boolean;
    };
    TextMessagePayload: components["schemas"]["MessagePreviewSupport"] & {
      /** @enum {string} */
      type: "text";
      /** @description Conteúdo textual da mensagem */
      text: string;
    };
    MediaMessagePayloadBase: components["schemas"]["MessagePreviewSupport"] & {
      /** @description Texto complementar opcional exibido como mensagem separada */
      text?: string;
      /** @description Legenda exibida junto à mídia */
      caption?: string;
      /**
       * Format: uri
       * @description URL pública da mídia
       */
      mediaUrl: string;
      /** @description MIME type da mídia */
      mimeType?: string;
      /** @description Nome sugerido do arquivo */
      fileName?: string;
    };
    ImageMessagePayload: components["schemas"]["MediaMessagePayloadBase"] & {
      /** @enum {string} */
      type: "image";
    };
    DocumentMessagePayload: components["schemas"]["MediaMessagePayloadBase"] & {
      /** @enum {string} */
      type: "document";
    };
    AudioMessagePayload: components["schemas"]["MediaMessagePayloadBase"] & {
      /** @enum {string} */
      type: "audio";
    };
    VideoMessagePayload: components["schemas"]["MediaMessagePayloadBase"] & {
      /** @enum {string} */
      type: "video";
    };
    LocationMessagePayload: components["schemas"]["MessagePreviewSupport"] & {
      /** @enum {string} */
      type: "location";
      /** @description Texto complementar opcional que acompanha o envio da localização */
      text?: string;
      location: {
        latitude: number;
        longitude: number;
        /** @description Nome amigável do local */
        name?: string;
        /** @description Endereço completo exibido no WhatsApp */
        address?: string;
        /**
         * Format: uri
         * @description URL de referência para o local
         */
        url?: string;
      };
    };
    ContactEmail: {
      /** Format: email */
      email: string;
      /** @description Rótulo do e-mail (ex. work, personal) */
      type?: string;
    };
    ContactPhone: {
      /** @description Número do contato no formato internacional */
      phoneNumber: string;
      /** @description Rótulo do telefone (ex. mobile, home) */
      type?: string;
      /** @description Identificador WhatsApp (JID) quando disponível */
      waId?: string;
    };
    ContactMessagePayload: components["schemas"]["MessagePreviewSupport"] & {
      /** @enum {string} */
      type: "contact";
      /** @description Texto complementar exibido junto ao cartão de contato */
      text?: string;
      contact: {
        /** @description Nome completo do contato */
        fullName?: string;
        /** @description Organização associada ao contato */
        organization?: string;
        emails?: components["schemas"]["ContactEmail"][];
        phones?: components["schemas"]["ContactPhone"][];
        /** @description Representação completa em vCard 3.0/4.0 */
        vcard?: string;
      };
    };
    TemplateLanguage: {
      /** @description Código do idioma (ex. pt_BR) */
      code: string;
      /**
       * @description Política de fallback do idioma
       * @enum {string}
       */
      policy?: "deterministic" | "fallback";
    };
    TemplateComponentTextParameter: {
      /** @enum {string} */
      type: "text";
      text: string;
    };
    TemplateComponentCurrencyParameter: {
      /** @enum {string} */
      type: "currency";
      currency: {
        /** @description Valor multiplicado por 1000 conforme contrato Meta */
        amount1000: number;
        currencyCode: string;
      };
    };
    TemplateComponentDateTimeParameter: {
      /** @enum {string} */
      type: "date_time";
      dateTime: {
        fallbackValue?: string;
        /** @description Epoch seconds */
        timestamp?: number;
      };
    };
    TemplateComponentImageParameter: {
      /** @enum {string} */
      type: "image";
      image: {
        /** Format: uri */
        link: string;
      };
    };
    TemplateComponentDocumentParameter: {
      /** @enum {string} */
      type: "document";
      document: {
        /** Format: uri */
        link: string;
        filename?: string;
      };
    };
    TemplateComponentVideoParameter: {
      /** @enum {string} */
      type: "video";
      video: {
        /** Format: uri */
        link: string;
      };
    };
    TemplateComponentParameter: components["schemas"]["TemplateComponentTextParameter"] | components["schemas"]["TemplateComponentCurrencyParameter"] | components["schemas"]["TemplateComponentDateTimeParameter"] | components["schemas"]["TemplateComponentImageParameter"] | components["schemas"]["TemplateComponentDocumentParameter"] | components["schemas"]["TemplateComponentVideoParameter"];
    TemplateComponent: {
      /** @enum {string} */
      type: "header" | "body" | "footer" | "button";
      /** @enum {string} */
      subType?: "quick_reply" | "url" | "copy_code" | "phone_number";
      /** @description Índice do componente conforme posição no template */
      index?: string;
      parameters?: components["schemas"]["TemplateComponentParameter"][];
    };
    TemplateMessagePayload: components["schemas"]["MessagePreviewSupport"] & {
      /** @enum {string} */
      type: "template";
      /** @description Texto complementar opcional (exibido como fallback) */
      text?: string;
      template: {
        namespace: string;
        name: string;
        language: components["schemas"]["TemplateLanguage"];
        components?: components["schemas"]["TemplateComponent"][];
      };
    };
    PollMessagePayload: {
      /** @enum {string} */
      type: "poll";
      poll: {
        question: string;
        options: string[];
        allowMultipleAnswers?: boolean;
      };
    };
    SendMessageByTicketRequest: {
      /** @description Identificador opcional da instância do WhatsApp */
      instanceId?: string;
      payload: components["schemas"]["MessagePayload"];
      /** @description Chave utilizada para deduplicação de requisições que deve corresponder ao cabeçalho Idempotency-Key */
      idempotencyKey: string;
    };
    SendMessageByContactRequest: components["schemas"]["SendMessageByTicketRequest"] & {
      /** @description Número de telefone do contato */
      to: string;
    };
    SendMessageByInstanceRequest: {
      /** @description Número de telefone do destinatário */
      to: string;
      payload: components["schemas"]["MessagePayload"];
      /** @description Chave utilizada para deduplicação de requisições que deve corresponder ao cabeçalho Idempotency-Key */
      idempotencyKey: string;
    };
    OutboundMessageError: {
      message: string;
      code?: string;
      status?: number;
      requestId?: string;
    };
    OutboundMessageResponse: {
      /** @enum {boolean} */
      queued: true;
      ticketId: string;
      messageId: string;
      status: string;
      externalId: string | null;
      error: components["schemas"]["OutboundMessageError"];
    };
    /**
     * @description Papel atribuído ao usuário dentro do tenant.
     * @enum {string}
     */
    UserRole: "ADMIN" | "SUPERVISOR" | "AGENT";
    UserSummary: {
      id: string;
      /** Format: email */
      email: string;
      name: string;
      role: components["schemas"]["UserRole"];
      isActive: boolean;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      lastLoginAt?: string | null;
    };
    CreateUserRequest: {
      name: string;
      /** Format: email */
      email: string;
      password: string;
      role: components["schemas"]["UserRole"];
    };
    UpdateUserRequest: {
      role?: components["schemas"]["UserRole"];
      isActive?: boolean;
    };
    UserListResponse: {
      /** @enum {boolean} */
      success: true;
      data: {
        users: components["schemas"]["UserSummary"][];
      };
    };
    UserMutationResponse: {
      /** @enum {boolean} */
      success: true;
      data: components["schemas"]["UserSummary"];
    };
    CreateUserInviteRequest: {
      /** Format: email */
      email: string;
      role: components["schemas"]["UserRole"];
      expiresInDays?: number;
    };
    UserInvite: {
      id: string;
      token: string;
      /** Format: email */
      email: string;
      /** Format: date-time */
      expiresAt?: string | null;
      /** @enum {string} */
      status: "pending" | "accepted" | "expired" | "revoked";
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    UserInviteResponse: {
      /** @enum {boolean} */
      success: true;
      data: components["schemas"]["UserInvite"];
    };
    ErrorResponse: {
      /** @enum {boolean} */
      success: false;
      error: {
        code: string;
        message: string;
        /** @description Informações adicionais sobre o erro */
        details?: unknown;
        [key: string]: unknown;
      };
    };
    ValidationErrorIssue: {
      code: string;
      message: string;
      path?: string[];
      [key: string]: unknown;
    };
    ValidationErrorResponse: components["schemas"]["ErrorResponse"] & {
      error?: {
        /** @enum {string} */
        code: "VALIDATION_ERROR";
        message: string;
        details: components["schemas"]["ValidationErrorIssue"][];
      };
    };
    RateLimitResponse: {
      /** @enum {boolean} */
      success: false;
      error: {
        /** @enum {string} */
        code: "RATE_LIMITED";
        message: string;
        retryAfterSeconds?: number;
      };
      data: {
        limit?: number;
        remaining?: number;
      };
      meta: {
        /** Format: date-time */
        resetAt?: string;
      };
    };
    /** @enum {string} */
    AgreementType: "municipal" | "estadual" | "federal" | "other";
    AgreementWindow: {
      id: string;
      tableId?: string | null;
      label: string;
      /** Format: date-time */
      startsAt?: string | null;
      /** Format: date-time */
      endsAt?: string | null;
      isActive: boolean;
      metadata: {
        [key: string]: unknown;
      };
    };
    AgreementRate: {
      id: string;
      tableId?: string | null;
      windowId?: string | null;
      product: string;
      modality: string;
      termMonths?: number | null;
      /** Format: float */
      coefficient?: number | null;
      /** Format: float */
      monthlyRate?: number | null;
      /** Format: float */
      annualRate?: number | null;
      /** Format: float */
      tacPercentage?: number | null;
      metadata?: {
        [key: string]: unknown;
      };
    };
    AgreementHistoryEntry: {
      id: string;
      actorId?: string | null;
      actorName?: string | null;
      action: string;
      message: string;
      /** Format: date-time */
      createdAt: string;
      metadata?: {
        [key: string]: unknown;
      };
    };
    Agreement: {
      id: string;
      tenantId: string;
      name: string;
      slug: string;
      status: components["schemas"]["AgreementStatus"];
      type?: components["schemas"]["AgreementType"];
      segment?: string | null;
      description?: string | null;
      tags: string[];
      products: {
        [key: string]: unknown;
      };
      metadata: {
        [key: string]: unknown;
      };
      archived: boolean;
      /** Format: date-time */
      publishedAt?: string | null;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      windows?: components["schemas"]["AgreementWindow"][];
      rates?: components["schemas"]["AgreementRate"][];
    };
    AgreementCollectionResponse: {
      data: components["schemas"]["Agreement"][];
      meta: {
        requestId?: string | null;
        /** Format: date-time */
        generatedAt: string;
        pagination?: {
          page?: number;
          limit?: number;
          totalItems?: number;
          totalPages?: number;
          hasNext?: boolean;
          hasPrevious?: boolean;
        };
      };
    };
    AgreementItemResponse: {
      data: components["schemas"]["Agreement"];
      meta: {
        /** Format: date-time */
        updatedAt?: string;
        requestId?: string | null;
      };
    };
    AgreementUpdateRequest: {
      data: components["schemas"]["AgreementUpdateInput"];
      meta?: {
        audit?: {
          actor?: string;
          actorRole?: string;
          note?: string;
        };
      };
    };
    AgreementUpdateInput: {
      name?: string;
      slug?: string;
      status?: components["schemas"]["AgreementStatus"];
      type?: components["schemas"]["AgreementType"];
      segment?: string;
      description?: string;
      tags?: string[];
      products?: {
        [key: string]: unknown;
      };
      metadata?: {
        [key: string]: unknown;
      };
      archived?: boolean;
      /** Format: date-time */
      publishedAt?: string | null;
    };
    AgreementImportError: {
      row: number;
      code?: string;
      message: string;
      column?: string;
    };
    AgreementImportResponse: {
      data: {
        imported: number;
        updated: number;
        failed: number;
        errors?: components["schemas"]["AgreementImportError"][];
      };
      meta: {
        jobId?: string;
        /** Format: date-time */
        processedAt?: string;
      };
    };
    AgreementImportErrorResponse: components["schemas"]["ErrorResponse"] & {
      data?: {
        errors?: components["schemas"]["AgreementImportError"][];
      };
      meta?: {
        jobId?: string;
      };
    };
    AgreementSyncRequest: {
      requestedBy?: string;
      reason?: string;
    };
    AgreementSyncResponse: {
      data: {
        providerId: string;
        /** @enum {string} */
        status: "queued" | "running" | "completed";
        syncId?: string;
      };
      meta: {
        /** Format: date-time */
        queuedAt?: string;
        etaSeconds?: number;
      };
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Enfileira uma nova mensagem para um ticket existente
   * @description Recebe os dados de uma nova mensagem outbound associada a um ticket existente e retorna o status do enfileiramento.
   */
  createTicketMessage: {
    parameters: {
      header: {
        /** @description Chave idempotente que deve corresponder ao corpo da requisição. */
        "Idempotency-Key": string;
      };
      path: {
        ticketId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendMessageByTicketRequest"];
      };
    };
    responses: {
      /** @description Mensagem enfileirada com sucesso */
      202: {
        content: {
          "application/json": components["schemas"]["OutboundMessageResponse"];
        };
      };
      /** @description Ticket ou instância não encontrada */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Instância desconectada */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Erro de validação na requisição */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
    };
  };
  /**
   * Lista acordos comerciais
   * @description Retorna uma coleção paginada de acordos aplicando filtros de status, provedor e período de vigência.
   */
  listAgreements: {
    parameters: {
      query?: {
        /** @description Número da página a ser retornada. */
        page?: number;
        /** @description Quantidade de itens por página. */
        pageSize?: number;
        /** @description Filtra acordos pelos status informados. */
        status?: components["schemas"]["AgreementStatus"][];
        /** @description Filtra acordos por identificador do provedor de origem. */
        providerId?: string[];
        /** @description Retorna apenas acordos válidos na data informada (ISO 8601, UTC). */
        validOn?: string;
        /** @description Texto livre aplicado em nome, descrição ou código externo do acordo. */
        search?: string;
      };
    };
    responses: {
      /** @description Lista paginada de acordos comerciais. */
      200: {
        content: {
          "application/json": components["schemas"]["AgreementListResponse"];
        };
      };
      /** @description Parâmetros inválidos para a listagem. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Limite de requisições excedido. */
      429: {
        headers: {
          /** @description Tempo em segundos até que uma nova tentativa seja permitida. */
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["RateLimitResponse"];
        };
      };
    };
  };
  /**
   * Cria um novo acordo comercial
   * @description Registra um novo acordo com suas tabelas, janelas e taxas vigentes.
   */
  createAgreement: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AgreementCreateRequest"];
      };
    };
    responses: {
      /** @description Acordo criado com sucesso. */
      201: {
        content: {
          "application/json": components["schemas"]["AgreementResponse"];
        };
      };
      /** @description Dados inválidos para criação do acordo. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Já existe um acordo ativo conflitante para o provedor informado. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Falhas de validação no payload enviado. */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
    };
  };
  /**
   * Recupera detalhes de um acordo comercial
   * @description Retorna o acordo completo com tabelas, janelas, taxas e metadados vigentes.
   */
  getAgreement: {
    parameters: {
      path: {
        /** @description Identificador único do acordo. */
        agreementId: string;
      };
    };
    responses: {
      /** @description Dados completos do acordo solicitado. */
      200: {
        content: {
          "application/json": components["schemas"]["AgreementResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Acordo não encontrado. */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Atualiza parcialmente um acordo comercial
   * @description Permite ajustes pontuais no acordo, como mudança de status, vigência ou definição de novas taxas.
   */
  updateAgreement: {
    parameters: {
      path: {
        /** @description Identificador único do acordo. */
        agreementId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AgreementUpdateRequest"];
      };
    };
    responses: {
      /** @description Acordo atualizado com sucesso. */
      200: {
        content: {
          "application/json": components["schemas"]["AgreementResponse"];
        };
      };
      /** @description Payload inválido para atualização. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Acordo não encontrado. */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Conflito ao atualizar o acordo (ex. vigência sobreposta). */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Falhas de validação no payload enviado. */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
    };
  };
  /**
   * Importa acordos comerciais em lote
   * @description Permite subir novos acordos em massa via upload de planilha ou JSON estruturado. A importação é assíncrona e retorna o identificador do job.
   */
  importAgreements: {
    requestBody: {
      content: {
        "multipart/form-data": components["schemas"]["AgreementImportMultipartRequest"];
        "application/json": components["schemas"]["AgreementImportRequest"];
      };
    };
    responses: {
      /** @description Importação enfileirada para processamento. */
      202: {
        content: {
          "application/json": components["schemas"]["AgreementImportResponse"];
        };
      };
      /** @description Payload inválido para importação. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Já existe um job de importação em andamento para o provedor informado. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Erros de validação encontrados no conteúdo enviado. */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
    };
  };
  /**
   * Dispara sincronização de acordos para um provedor
   * @description Agenda uma sincronização assíncrona dos acordos ativos com o provedor remoto.
   */
  triggerProviderAgreementSync: {
    parameters: {
      path: {
        /** @description Identificador do provedor de integrações. */
        providerId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ProviderSyncRequest"];
      };
    };
    responses: {
      /** @description Sincronização agendada. */
      202: {
        content: {
          "application/json": components["schemas"]["ProviderSyncResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Provedor não encontrado. */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Já existe uma sincronização em andamento para o provedor informado. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Enfileira uma nova mensagem para um contato específico
   * @description Cria uma nova mensagem outbound vinculada a um contato e opcionalmente a uma instância específica de WhatsApp.
   */
  createContactMessage: {
    parameters: {
      header?: {
        /** @description Opcionalmente garante idempotência quando informado. */
        "Idempotency-Key"?: string;
      };
      path: {
        contactId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendMessageByContactRequest"];
      };
    };
    responses: {
      /** @description Mensagem enfileirada com sucesso */
      202: {
        content: {
          "application/json": components["schemas"]["OutboundMessageResponse"];
        };
      };
      /** @description Contato ou instância não encontrada */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Instância desconectada */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Erro de validação na requisição */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
    };
  };
  /**
   * Enfileira uma nova mensagem para envio ad-hoc via instância WhatsApp
   * @description Permite enviar mensagens outbound ad-hoc usando apenas a instância do WhatsApp e o telefone de destino.
   */
  createInstanceMessage: {
    parameters: {
      header: {
        /** @description Chave idempotente necessária para evitar envios duplicados. */
        "Idempotency-Key": string;
      };
      path: {
        instanceId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendMessageByInstanceRequest"];
      };
    };
    responses: {
      /** @description Mensagem enfileirada com sucesso */
      202: {
        content: {
          "application/json": components["schemas"]["OutboundMessageResponse"];
        };
      };
    };
  };
  /**
   * Lista usuários do tenant autenticado
   * @description Retorna os usuários cadastrados no tenant filtrando por status ativo ou inativo.
   */
  listUsers: {
    parameters: {
      query?: {
        /** @description Filtra usuários por status (ativo, inativo ou todos). */
        status?: "all" | "active" | "inactive";
      };
    };
    responses: {
      /** @description Coleção de usuários do tenant. */
      200: {
        content: {
          "application/json": components["schemas"]["UserListResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada para o perfil do usuário. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Cria um novo usuário para o tenant */
  createUser: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserRequest"];
      };
    };
    responses: {
      /** @description Usuário criado com sucesso. */
      201: {
        content: {
          "application/json": components["schemas"]["UserMutationResponse"];
        };
      };
      /** @description Payload inválido. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Usuário com o mesmo e-mail já existe. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Gera um convite para um novo usuário do tenant */
  createUserInvite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserInviteRequest"];
      };
    };
    responses: {
      /** @description Convite criado com sucesso. */
      201: {
        content: {
          "application/json": components["schemas"]["UserInviteResponse"];
        };
      };
      /** @description Payload inválido. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Usuário com o mesmo e-mail já existe. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Desativa um usuário do tenant */
  deactivateUser: {
    parameters: {
      path: {
        userId: string;
      };
    };
    responses: {
      /** @description Usuário desativado com sucesso. */
      200: {
        content: {
          "application/json": components["schemas"]["UserMutationResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Usuário não encontrado. */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Não é permitido desativar o próprio usuário. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Atualiza role ou status de um usuário existente */
  updateUser: {
    parameters: {
      path: {
        userId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequest"];
      };
    };
    responses: {
      /** @description Usuário atualizado com sucesso. */
      200: {
        content: {
          "application/json": components["schemas"]["UserMutationResponse"];
        };
      };
      /** @description Payload inválido. */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationErrorResponse"];
        };
      };
      /** @description Requisição não autenticada. */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Operação não autorizada. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Usuário não encontrado. */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
}
