diff --git a/apps/api/src/services/lead-engine-client.ts b/apps/api/src/services/lead-engine-client.ts
index 1111111..2222222 100644
--- a/apps/api/src/services/lead-engine-client.ts
+++ b/apps/api/src/services/lead-engine-client.ts
@@ -1,12 +1,17 @@
    import { fetch, type RequestInit } from 'undici';
    -import { leadEngineConfig, agreementDefinitions, AgreementSummary, BrokerLeadRecord } from '../config/lead-engine';
    +import { leadEngineConfig, agreementDefinitions, AgreementSummary, BrokerLeadRecord } from '../config/lead-engine';
     import { logger } from '../config/logger';
 
 const FALLBACK_LEADS: BrokerLeadRecord[] = [
   {
     id: 'demo-lead-1',
     fullName: 'Maria Helena Souza',
     document: '09941751919',
     registrations: ['1839'],
     agreementId: 'saec-goiania',
     phone: '+5562999887766',
     margin: 487.5,
     netMargin: 390.0,
     score: 92,
     tags: ['respondido', 'whatsapp'],
   },
    @@ -43,44 +48,121 @@ class LeadEngineClient {
   private readonly baseUrl = leadEngineConfig.baseUrl?.replace(/\/$/, '') || '';
   private readonly timeoutMs = leadEngineConfig.timeoutMs;
-  private readonly token = leadEngineConfig.basicToken;
+  private readonly token = leadEngineConfig.basicToken;
+
+  /** Garante que o header Authorization esteja no formato correto */
+  private ensureBasic(token?: string): string | undefined {
+    if (!token) return undefined;
+    return token.startsWith('Basic ') ? token : `Basic ${token}`;
+  }
 
   private async request<T>(path: string, init?: RequestInit): Promise<T> {
     if (!this.baseUrl || !this.token) {
       logger.warn('Lead Engine broker request aborted: configuration is incomplete', {
         hasBaseUrl: Boolean(this.baseUrl),
         hasToken: Boolean(this.token),
         attemptedPath: path,
       });
       throw new Error('Lead Engine broker is not configured');
     }
 
     const controller = new AbortController();
     const timeout = setTimeout(() => controller.abort(), this.timeoutMs);
 
     try {
       logger.info('Calling Lead Engine broker', {
         url: `${this.baseUrl}${path}`,
         timeoutMs: this.timeoutMs,
       });
 
       const response = await fetch(`${this.baseUrl}${path}`, {
         ...init,
         headers: {
-          Authorization: `Basic ${this.token}`,
+          // ⚠️ antes: `Basic ${this.token}` — duplicava "Basic " se a env já vinha com prefixo
+          Authorization: this.ensureBasic(this.token)!,
           'Content-Type': 'application/json',
           ...(init?.headers || {}),
         },
         signal: controller.signal,
       });
 
       if (!response.ok) {
         const text = await response.text();
         logger.error('Lead Engine broker responded with an error status', {
           status: response.status,
           body: text,
           path,
         });
         throw new Error(`Broker request failed (${response.status}) ${text}`);
       }
 
       return (await response.json()) as T;
     } catch (error) {
       logger.warn('Lead Engine broker request failed', {
         path,
         message: error instanceof Error ? error.message : 'Unknown error',
       });
       throw error;
     } finally {
       clearTimeout(timeout);
     }
   }
 
+  /**
+   * Conta leads reais no broker via /api/v1/lead usando apenas o "total".
+   * Faz uma consulta com _page=0&_size=1 para minimizar transferência.
+   * Aceita filtros como agreementCode e classification/leadStatus.
+   */
+  private async countLeads(params: Record<string, string | number | boolean | undefined>): Promise<number> {
+    const q = new URLSearchParams();
+    q.set('_page', '0');
+    q.set('_size', '1');
+
+    // Datas padrão (se existirem no config)
+    // Se não quiser filtrar por data, comente as duas linhas abaixo.
+    if ((leadEngineConfig as any).defaultStartDate) {
+      q.set('startDateUtc', (leadEngineConfig as any).defaultStartDate);
+    }
+    if ((leadEngineConfig as any).defaultEndDate) {
+      q.set('endDateUtc', (leadEngineConfig as any).defaultEndDate);
+    }
+
+    // Demais filtros (agreementCode, classification, leadStatus etc.)
+    Object.entries(params).forEach(([k, v]) => {
+      if (v !== undefined && v !== null) q.set(k, String(v));
+    });
+
+    type BrokerCountRes =
+      | { value?: { total?: number } }
+      | { total?: number }
+      | { success?: boolean; value?: { total?: number } };
+
+    const res = await this.request<BrokerCountRes>(`/api/v1/lead?${q.toString()}`);
+    // Formatos aceitos:
+    // - { value: { total } }  (padrão que você mostrou)
+    // - { total }
+    const total =
+      (res as any)?.value?.total ??
+      (res as any)?.total ??
+      0;
+    return Number.isFinite(total) ? total : 0;
+  }
+
   async getAgreementSummaries(): Promise<AgreementSummary[]> {
-    try {
-      logger.info('Fetching agreement summaries from Lead Engine broker');
-      const payload = await this.request<{ agreements?: Array<Record<string, unknown>> }>('/api/dashboard');
-      const summariesBySlug = new Map<string, Record<string, unknown>>();
-      if (Array.isArray(payload.agreements)) {
-        payload.agreements.forEach((item) => {
-          const slug = typeof item?.slug === 'string' ? item.slug : undefined;
-          if (slug) {
-            summariesBySlug.set(slug, item);
-          }
-        });
-      }
-
-      return agreementDefinitions.map((definition) => {
-        const stats = summariesBySlug.get(definition.slug) ?? {};
-        return {
-          ...definition,
-          availableLeads: typeof stats.availableLeads === 'number' ? stats.availableLeads : 0,
-          hotLeads: typeof stats.hotLeads === 'number' ? stats.hotLeads : 0,
-          lastSyncAt: typeof stats.lastSyncAt === 'string' ? stats.lastSyncAt : null,
-        } satisfies AgreementSummary;
-      });
-    } catch (error) {
+    try {
+      logger.info('Fetching agreement summaries from Lead Engine broker (via /api/v1/lead total)');
+
+      // Disparamos todas as contagens em paralelo para performance
+      const results = await Promise.all(
+        agreementDefinitions.map(async (def) => {
+          const agreementCode = def.slug; // <- o broker usa os "SaecGoiania", "Rf1BoaVista" etc.
+
+          // total por convênio
+          const total = await this.countLeads({ agreementCode });
+
+          // "hot" — escolha o seu filtro:
+          // (A) se for classification=2:
+          const hot = await this.countLeads({ agreementCode, classification: 2 });
+          // (B) se for leadStatus=2, troque a linha acima por:
+          // const hot = await this.countLeads({ agreementCode, leadStatus: 2 });
+
+          const now = new Date().toISOString();
+          const summary: AgreementSummary = {
+            ...def,
+            availableLeads: total,
+            hotLeads: hot,
+            lastSyncAt: now,
+          };
+          return summary;
+        })
+      );
+
+      return results;
+    } catch (error) {
       logger.warn('Falling back to local agreement summaries', {
         message: error instanceof Error ? error.message : 'Unknown error',
       });
    @@ -92,34 +174,64 @@ class LeadEngineClient {
       }));
     }
   }
 
   async fetchLeads(options: {
     agreementId: string;
     take: number;
   }): Promise<BrokerLeadRecord[]> {
     const { agreementId, take } = options;
 
     try {
       logger.info('Requesting leads from Lead Engine broker', {
         agreementId,
         take,
       });
-      const params = new URLSearchParams();
-      params.set('agreementId', agreementId);
-      params.set('_size', String(Math.min(Math.max(take, 1), 100)));
-      params.set('_page', '0');
-
-      const payload = await this.request<{ data?: BrokerLeadRecord[]; items?: BrokerLeadRecord[] }>(
-        `/api/leads?${params.toString()}`
-      );
-
-      const leads = Array.isArray(payload.data)
-        ? payload.data
-        : Array.isArray(payload.items)
-        ? payload.items
-        : [];
+      const params = new URLSearchParams();
+      // mapeia id (ex.: "saec-goiania") -> slug do broker (ex.: "SaecGoiania")
+      const def = agreementDefinitions.find(d => d.id === agreementId);
+      const agreementCode = def?.slug ?? agreementId;
+      params.set('agreementCode', agreementCode);
+      params.set('_size', String(Math.min(Math.max(take, 1), 100)));
+      params.set('_page', '0');
+
+      // Datas padrão (se houver)
+      if ((leadEngineConfig as any).defaultStartDate) {
+        params.set('startDateUtc', (leadEngineConfig as any).defaultStartDate);
+      }
+      if ((leadEngineConfig as any).defaultEndDate) {
+        params.set('endDateUtc', (leadEngineConfig as any).defaultEndDate);
+      }
+
+      type BrokerListRes =
+        | { value?: { data?: BrokerLeadRecord[] } }
+        | { data?: BrokerLeadRecord[]; items?: BrokerLeadRecord[] };
+
+      // ⚠️ troca de /api/leads -> /api/v1/lead
+      const payload = await this.request<BrokerListRes>(`/api/v1/lead?${params.toString()}`);
+
+      const leads =
+        (payload as any)?.value?.data ??
+        (payload as any)?.data ??
+        (payload as any)?.items ??
+        [];
 
       if (leads.length === 0) {
         logger.warn('Broker responded without leads, falling back to demo data', {
           agreementId,
         });
         return this.fallback(agreementId, take);
       }
 
       logger.info('Leads retrieved from broker', {
         agreementId,
         requested: take,
         received: leads.length,
       });
-      return leads.map((lead) => ({
+      return (leads as BrokerLeadRecord[]).map((lead) => ({
         ...lead,
-        agreementId: lead.agreementId || agreementId,
+        // garante coerência do agreementId
+        agreementId: lead.agreementId || agreementId,
       }));
     } catch (error) {
       logger.warn('Failed to fetch leads from broker, using demo data', {
         agreementId,
         message: error instanceof Error ? error.message : 'Unknown error',
       });
       return this.fallback(agreementId, take);
     }
    }
   }
 }
}